# -*- coding: utf-8 -*-
"""Regression forecast and EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ilfDQ6QBBXKkwSCwZ3gmenRkhRVsDCaF
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import pandas as pd
import pandas_datareader.data as web
import plotly.express as px
import seaborn as sns
import pytz
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error

import warnings
warnings.simplefilter(action="ignore", category=FutureWarning)
# %matplotlib inline

#Get the stock quote
ps_data = pd.read_csv("data.csv",sep=";")
#Read the close price data
print(ps_data)

ps_data["Case"]=ps_data["Case"].diff()
ps_data["Case"].fillna(1,inplace=True)
ps_data["Case"]=ps_data["Case"].astype(int)

ps_data["Death"]=ps_data["Death"].diff()
ps_data["Death"].fillna(0,inplace=True)
ps_data["Death"]=ps_data["Death"].astype(int)

ps_data["Recovered"]=ps_data["Recovered"].diff()
ps_data["Recovered"].fillna(0,inplace=True)
ps_data["Recovered"]=ps_data["Recovered"].astype(int)

ps_data["People_partially_vaccinated"]=ps_data["People_partially_vaccinated"].diff()
ps_data["People_partially_vaccinated"].fillna(0,inplace=True)
ps_data["People_partially_vaccinated"]=ps_data["People_partially_vaccinated"].astype(int)

ps_data["People_fully_vaccinated"]=ps_data["People_fully_vaccinated"].diff()
ps_data["People_fully_vaccinated"].fillna(0,inplace=True)
ps_data["People_fully_vaccinated"]=ps_data["People_fully_vaccinated"].astype(int)

ps_data["Doses_admin"]=ps_data["Doses_admin"].diff()
ps_data["Doses_admin"].fillna(0,inplace=True)
ps_data["Doses_admin"]=ps_data["Doses_admin"].astype(int)



#ps_data=ps_data[["Date","Case"]]
date_column= "Date"
pred_column="Case"
ps_data[date_column]=pd.to_datetime(ps_data[date_column])
ps_data.set_index('Date', inplace=True)
ps_data.info()

df= ps_data
print(df.shape)
df.head()

import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose

# Decompose the 'Case' time series
decomposition = seasonal_decompose(df['Case'], model='additive')

# Plot the decomposed components
decomposition.plot().suptitle('Time Series Decomposition of Case Data')

import numpy as np

residuals = decomposition.resid.dropna()  # Removing NaN values which are a result of the decomposition
z_scores = np.abs((residuals - residuals.mean()) / residuals.std())

threshold = 3
anomalies = residuals[z_scores > threshold]

# Replace anomalies with the median value of 'Case'
median_value = df['Case'].median()
df.loc[anomalies.index, 'Case'] = median_value

fig, ax = plt.subplots(figsize=(15, 6))
sns.distplot(df["Case"], kde=True, color='brown', bins=18, ax=ax)

# Setting x-axis ticks
ax.set_xticks(range(0, 110001, 10000))

ax.set_title("Distribution of Case")
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

plt.figure(figsize=(14, 5))  # Set the figure size to 10x6 inches

# Plot histogram with density estimation using Seaborn
sns.histplot(df["Case"], kde=True)

# Customize the plot
plt.grid(True, linestyle='--', alpha=0.7)  # Add grid lines
plt.xticks(np.arange(0, 100001, 10000))  # Set x-axis ticks from 0 to 100,000 by 10,000

# Add labels and title
plt.xlabel('Value')
plt.ylabel('Density')
plt.title('Histogram with Density Estimation')

# Show the plot
plt.show()

fig, ax = plt.subplots(figsize=(15, 6))
df["Case"].plot(kind="box", vert=False, title="Distribution of Case", ax=ax)

# Setting x-axis ticks
ax.set_xticks(range(0, 110001, 10000))

plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Generate some random data
data = df["Case"]

plt.figure(figsize=(14, 5))  # Set the figure size to 10x6 inches

# Create a horizontal box plot
sns.boxplot(x=data, orient='h')

# Customize the plot
plt.grid(True, linestyle='--', alpha=0.7)  # Add grid lines
plt.xticks(np.arange(0, 100001, 10000))  # Set x-axis ticks from 0 to 100,000 by 10,000
plt.xlabel('Case Numbers')

plt.title('Box Plot of Cases')

# Show the plot
plt.show()

df["Case"].value_counts()

fig, ax = plt.subplots(figsize=(15, 6))
sns.lineplot(x = df.index, y = df['Case'], data = df, ax=ax)
ax.set_title("Close Price Time Series");

fig, ax = plt.subplots(figsize=(15, 6))
sns.lineplot(x = df.index, y = df["Case"].rolling(30).mean(), data = df, ax=ax)
ax.set_title("Monthly Rolling Average")

ps_data.info()

df["Case.L1"] = df["Case"].shift(1)
df.dropna(0,inplace = True)
print(df)

#ps_data = ps_data[["Date","Case","Recovered","People_partially_vaccinated","People_fully_vaccinated","Doses_admin"]]

df = df[["Case","Doses_admin","Case.L1"]]


df.head(10)



df.corr()

num_negatives = np.sum(df["Doses_admin"] < 0)

print("Total number of negative values:", num_negatives)

import numpy as np

# Generate some random data
data = df["Doses_admin"]

# Find the indices of negative values
negative_indices = np.where(data < 0)

print("Indices of negative values:", negative_indices)

data[599]

df["Doses_admin"]= abs(df["Doses_admin"])

df["Doses_admin"].max()

import pandas as pd
from statsmodels.tsa.seasonal import seasonal_decompose

# Decompose the 'Case' time series
decomposition = seasonal_decompose(df['Doses_admin'], model='additive')

# Plot the decomposed components
decomposition.plot().suptitle('Time Series Decomposition of Doses admin')

df["Doses_admin"].plot(figsize=(12,6))

fig, ax = plt.subplots(figsize=(15, 6))
ax.scatter(x=df["Case.L1"], y=df["Case"])
ax.plot([0,800],[0,800],linestyle="--", color="red")
plt.xlabel("Doses Admin")
plt.ylabel("Case")
plt.title("Scatter plot of Case vs Doses Admin")

plt.figure(figsize=(14, 5))

# Plotting the scatter plot
plt.scatter(df["Doses_admin"],df["Case"], color='blue', marker='o', s=100, label='Data Points')  # Customize marker size, color, etc.

# Adding a diagonal line


# Setting x-axis limits and ticks
plt.xlim(0, 1700000)
plt.xticks(range(0, 1700001, 200000))

# Adding labels and title
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Scatter Plot')

# Adding grid
plt.grid(True, linestyle='--', alpha=0.7)

# Adding legend
plt.legend()

# Display the plot
plt.show()

# Split the data into featuer and target
target = "Case"
y = df[target]
X = df.drop(columns= target)
#Split the data into train and test sets
cutoff = int(len(X) * 0.992)
X_train, y_train = X.iloc[:cutoff], y.iloc[:cutoff]
X_test, y_test = X.iloc[cutoff:], y.iloc[cutoff:]
print(y_train)

y_pred_baseline = [y_train.mean()] * len(y_train)
mae_baseline = mean_absolute_error(y_train, y_pred_baseline)
print("Mean Close Prices:", round(y_train.mean(), 2))
print("Baseline MAE:", round(mae_baseline, 2))

model = LinearRegression()
model.fit(X_train, y_train)
LinearRegression()

training_mae = mean_absolute_error(y_train, model.predict(X_train))
test_mae = mean_absolute_error(y_test, model.predict(X_test))
print("Training MAE:", round(training_mae, 2))
print("Test MAE:", round(test_mae, 2))

intercept = model.intercept_.round(2)
coefficient = model.coef_.round(2)
print(f"Case = {intercept} + ({coefficient} * Close.L1)")
print(coefficient)

coefficient

df_pred_test = pd.DataFrame(
             {
             "Test": y_test,
             "Forecast": model.predict(X_test)
             }
)
df_pred_test.tail()

df_pred_test.plot(figsize=(14,5),title="Actual vs Predicted Values")
plt.ylim(500, 1400)
plt.show()

from sklearn.metrics import mean_squared_error
from math import sqrt
rmse=sqrt(mean_squared_error(df_pred_test["y_test"], df_pred_test["y_pred"]))
print(rmse)

from sklearn.metrics import mean_absolute_error, mean_squared_error, mean_absolute_percentage_error

# Calculating MAE, MSE, and MAPE between case and pred columns
mae = mean_absolute_error(df_pred_test["y_test"], df_pred_test["y_pred"])
mse = mean_squared_error(df_pred_test["y_test"], df_pred_test["y_pred"])
mape = mean_absolute_percentage_error(df_pred_test["y_test"], df_pred_test["y_pred"])

mae, mse, mape

df_train_test = pd.DataFrame(
             {
             "y_train": y_train,
             "y_train_pred": model.predict(X_train)
             }
)
df_train_test.tail()

fig= px.line(df_train_test, labels= {"value": "Close Price"}, title = "Linear Regression Model: Actual Case vs. Predicted Case.")

fig.show()



"""Visualizations"""

df.info()

df["Month"]

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'df' is your DataFrame
# Grouping the data by 'Month' and summing up the cases for each month
monthly_cases = df.groupby('Month')['Case'].sum().reset_index()

# Plotting the aggregated data
plt.figure(figsize=(10, 6))
plt.bar(monthly_cases['Month'], monthly_cases['Case'], color='skyblue')
plt.xlabel('Month')
plt.ylabel('Number of Cases')
plt.title('Number of Cases Per Month')
plt.xticks(monthly_cases['Month'])  # Ensure all months are displayed
plt.show()

print(monthly_cases)

monthly_deaths = df.groupby('Month')['Death'].sum().reset_index()

# Plotting the aggregated data
plt.figure(figsize=(10, 6))
plt.bar(monthly_deaths['Month'], monthly_deaths['Death'], color='purple')
plt.xlabel('Month')
plt.ylabel('Number of Death')
plt.title('Number of Death Per Month')
plt.xticks(monthly_deaths['Month'])  # Ensure all months are displayed
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Improve the aesthetics using seaborn
sns.set(style="whitegrid")

plt.figure(figsize=(12, 8))

# Create a boxplot with customized colors and display median values
box = plt.boxplot([df[df['Season'] == 1]['Case'],
                   df[df['Season'] == 2]['Case'],
                   df[df['Season'] == 3]['Case'],
                   df[df['Season'] == 4]['Case']],
                  labels=['Winter', 'Spring', 'Summer', 'Fall'],
                  patch_artist=True,  # Fill with color
                  medianprops={'linewidth': 2, 'color': 'purple'})  # Customize median line

# Coloring each box
colors = ['lightblue', 'lightgreen', 'lightcoral', 'wheat']
for patch, color in zip(box['boxes'], colors):
    patch.set_facecolor(color)

# Adding titles and labels
plt.xlabel('Season', fontsize=14)
plt.ylabel('Number of Cases', fontsize=14)
plt.title('Distribution of Cases Across Seasons', fontsize=16)

# Annotate median values above the median lines
medians = [item.get_ydata()[0] for item in box['medians']]
for i, median in enumerate(medians):
    plt.text(i + 1, median, f'{median}', ha='center', va='bottom', fontsize=12, color='black')

plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()